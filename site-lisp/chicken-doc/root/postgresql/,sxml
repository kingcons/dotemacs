((tags "egg") (section 2 "postgresql" (toc) (section 3 "Description" (p "Bindings for " (link "http://www.postgresql.org/" "PostgreSQL") "'s C-api.")) (section 3 "Author" (p "Original author: " (int-link "mailto:johs@copyleft.no" "Johannes Grødem")) (p "Please do not mail to Johannes directly as he no longer develops this egg.") (p "Current maintainer: " (int-link "/users/peter-bex" "Peter Bex")) (section 4 "Thanks to" (ul (li "Felix L. Winkelmann") (li "Alex Shinn") (li "Ed Watkeys") (li "Taylor Campbell")))) (section 3 "Requirements" (ul (li (int-link "sql-null"))) (p "You will also need to have " (link "http://www.postgresql.org/docs/current/interactive/libpq.html" "libpq") " installed, including development headers.")) (section 3 "Documentation" (p "This extension provides an interface to the " (link "http://www.postgresql.org" "PostgreSQL") " relational database.") (section 4 "Connection management" (def (sig (procedure "(connect CONNECTION-SPEC [TYPE-PARSERS [TYPE-UNPARSERS]])" (id connect))) (p "Opens a connection to the database given in CONNECTION-SPEC, which should be either a PostgreSQL connection string or an alist with entries consisting of a symbol and a value (which is internally converted to such a string).  The symbols should be connection keywords recognized by PostgreSQL's connection function.  See the " (link "http://www.postgresql.org/docs/current/interactive/libpq-connect.html" "list of PQconnectdbParams parameter keywords") " in the PostgreSQL documentation. At the time of writing, they are " (tt "host") ", " (tt "hostaddr") ", " (tt "port") ", " (tt "dbname") ", " (tt "user") ", " (tt "password") ", " (tt "connect_timeout") ", " (tt "options") ", " (tt "sslmode") ", " (tt "service") ".") (p (tt "TYPE-PARSERS") " is an optional alist that maps PostgreSQL type names to parser procedures, TYPE-UNPARSERS is an optional alist that maps predicates to unparser procedures.  They default to " (tt "(default-type-parsers)") " and " (tt "(default-type-unparsers)") ", respectively (see " (int-link "#type-conversion" "below") ").") (p "The return value is a connection-object.") (p "Also note that while these bindings use the non-blocking interface to connect to PostgreSQL, if you specify a hostname (using the " (tt "host") "-keyword), the function might not be able to yield because the resolver will block.") (p (b "Note") ": You cannot use the same connection from multiple threads. If you need to talk to the same server from different threads, simply create a second connection.")) (def (sig (procedure "(disconnect CONNECTION)" (id disconnect))) (p "Disconnects from the given " (tt "CONNECTION") ".")) (def (sig (procedure "(reset-connection CONNECTION)" (id reset-connection))) (p "Resets, that is, reopens the connection with the same connection-specs as was given when opening the original " (tt "CONNECTION") ".")) (def (sig (procedure "(type-parsers CONNECTION)" (id type-parsers))) (p "Retrieve the alist of type parsers associated with the " (tt "CONNECTION") ".")) (def (sig (procedure "(type-unparsers CONNECTION)" (id type-unparsers))) (p "Retrieve the alist of type unparsers associated with the " (tt "CONNECTION") ".")) (def (sig (procedure "(connection? OBJECT)" (id connection?))) (p "Returns true if OBJECT is a PostgreSQL connection-object."))) (section 4 "Query procedures" (def (sig (procedure "(query CONN QUERY . PARAMS)" (id query))) (p "Execute " (tt "QUERY") ", which is a string containing one SQL statement. " (tt "CONN") " indicates the connection on which to execute the query, and " (tt "PARAMS") " is an arbitrary number of optional arguments indicating positional parameters (" (tt "$1") ", " (tt "$2") " etc).") (p "This returns a result object (see below).") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n  (row-values (query conn \"SELECT $1::text, 2::int2\" \"hello\")))\n => ((\"hello\" 2))")) (def (sig (procedure "(query* CONN QUERY [PARAMS] [format: FORMAT] [raw: RAW?])" (id query*))) (p "A less convenient but slightly more powerful version of the " (tt "query") " procedure; " (tt "PARAMS") " must now be a list (instead of rest-arguments). " (tt "FORMAT") " is a symbol specifying how to return the resultset: either as " (tt "binary") " or " (tt "text") " (the default).  " (tt "RAW") " is a boolean which defines whether the " (tt "PARAMS") " should be treated \"raw\" or first passed through the unparsers associated with " (tt "CONN") ".  If they are treated \"raw\", they must all be strings, blobs or sql-null objects.") (p "See " (int-link "#type-conversion" "type conversion") " for more info on unparsers.") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n  (row-map*\n    (lambda (a b) (list (blob->string a) (blob->u8vector b)))\n    (query* conn \"SELECT $1::text, 2::int2\" '(\"hello\") format: 'binary)))\n => ((\"hello\" #u8(0 2)))"))) (section 4 "High-level API" (p "Usually you will use only these procedures to process result sets, but you can fall back to (or even mix with) the low-level API if you need to do custom things.") (def (sig (procedure "(row-fold KONS KNIL RESULT)" (id row-fold)) (procedure "(row-fold* KONS KNIL RESULT)" (id row-fold*))) (p "This is the fundamental result set iterator. It calls " (tt "(kons row seed)") " for every row, where " (tt "row") " is the list of values in the current row and " (tt "seed") " is the accumulated result from previous calls (initially " (tt "knil") "), ie its pattern looks like " (tt "(KONS ROWN ... (KONS ROW2 (KONS ROW1 KNIL)))") ".  It returns the final accumulated result.") (p "The starred version works the same, except it calls " (tt "(kons rowN-col1 rowN-col2 ... seed)") " instead of " (tt "(kons rowN seed)") ", so the procedure must know how many columns you have in the result set.") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n   (row-fold (lambda (row sum) (+ (car row) sum))\n             0\n             (query conn \"SELECT 1 UNION SELECT 2\")))\n => 3\n\n(let ((conn (connect '((dbname . test)))))\n   (row-fold* (lambda (value str) (string-append str value))\n              \"\"\n              (query conn \"SELECT 'hello, ' UNION SELECT 'world'\")))\n => \"hello, world\"")) (def (sig (procedure "(column-fold KONS KNIL RESULT)" (id column-fold)) (procedure "(column-fold* KONS KNIL RESULT)" (id column-fold*))) (p "As " (tt "row-fold") "/" (tt "row-fold*") ", except this iterates sideways through the columns instead of lengthways through the columns, calling " (tt "KONS") " with all values in all the rows of the current column, from left to right.") (p "The starred version is much less useful here since you often don't know the number of returned columns, but it is provided for consistency.") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n   (column-fold (lambda (col sum) (+ (car col) sum))\n                0\n                (query conn \"SELECT 1, 100 UNION SELECT 2, 200\")))\n => 101")) (def (sig (procedure "(row-fold-right KONS KNIL RESULT)" (id row-fold-right)) (procedure "(row-fold-right* KONS KNIL RESULT)" (id row-fold-right*))) (p "The fundamental result set recursion operator;  Calls " (tt "(KONS COL1 (KONS COL2 (KONS ... KNIL)))") " instead of " (tt "(KONS COLN ... (KONS COL2 (KONS COL1 KNIL)))") ".")) (def (sig (procedure "(column-fold-right KONS KNIL RESULT)" (id column-fold-right)) (procedure "(column-fold-right* KONS KNIL RESULT)" (id column-fold-right*))) (p "Column variants of " (tt "row-fold-right") "/" (tt "row-fold-right*") ".")) (def (sig (procedure "(row-for-each PROC RESULT)" (id row-for-each)) (procedure "(row-for-each* PROC RESULT)" (id row-for-each*))) (p "Simple " (tt "for-each") ", calling the " (tt "(PROC row)") " on each row, in turn, only for the purpose of its side-effects.  The starred version calls " (tt "(PROC col1 col2 ...)") ".")) (def (sig (procedure "(column-for-each PROC RESULT)" (id column-for-each)) (procedure "(column-for-each* PROC RESULT)" (id column-for-each*))) (p "Column variants of " (tt "row-for-each") "/" (tt "row-for-each*") ".")) (def (sig (procedure "(row-map PROC RESULT)" (id row-map)) (procedure "(row-map* PROC RESULT)" (id row-map*))) (p "Maps rows to lists by applying " (tt "PROC") " to every row and using its result in the result list on the position corresponding to that of the row.  This procedure is not guaranteed to walk the result set in any particular order, so do " (i "not") " rely on the order " (tt "PROC") " will be called.") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n   (row-map* + (query conn \"SELECT 1, 100 UNION SELECT 2, 200\")))\n => (101 202)")) (def (sig (procedure "(column-map PROC RESULT)" (id column-map)) (procedure "(column-map* PROC RESULT)" (id column-map*))) (p "Column variants of " (tt "row-map") "/" (tt "row-map*") ".") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n   (column-map* + (query conn \"SELECT 1, 100 UNION SELECT 2, 200\")))\n => (3 300)")) (section 5 "Transaction management" (def (sig (procedure "(with-transaction CONN THUNK)" (id with-transaction))) (p "Execute " (tt "THUNK") " within a " (tt "BEGIN TRANSACTION") " block, and return the value of " (tt "thunk") ".") (p "The transaction is committed if " (tt "thunk") " returns a true value.  If an exception occurs during " (tt "thunk") ", or " (tt "thunk") " returns " (tt "#f") ", or the commit fails, the transaction will be rolled back. If this rollback fails, that is a critical error and you should likely abort.") (p "Nested applications of " (tt "with-transaction") " " (b "are") " supported -- only those statements executed within " (tt "THUNK") " are committed or rolled back by any " (tt "with-transaction") " call, as you would expect.") (p "However, escaping or re-entering the dynamic extent of " (tt "thunk") " will not commit or rollback the in-progress transaction, so it is highly discouraged to jump out of a transaction.  You will definitely run into trouble, unless you can ensure that no other statements will be executed on this connection until the outermost " (tt "with-transaction") " returns normally.")) (def (sig (procedure "(in-transaction? CONN)" (id in-transaction?))) (p "Returns " (tt "#t") " if there is currently a transaction in progress on the connection " (tt "CONN") ".  Returns " (tt "#f") " if no transaction is in progress.")))) (section 4 "Low-level result API" (p "This API allows you to inspect result objects on the individual row and column level.") (def (sig (procedure "(result? OBJ)" (id result?))) (p "Returns " (tt "#t") " when " (tt "OBJ") " is a result object, " (tt "#f") " otherwise.")) (def (sig (procedure "(clear-result! RES)" (id clear-result!))) (p "Directly clean up all memory used by the result object.  This is normally deferred until garbage collection, but it's made available for when you want more control over when results are released.")) (def (sig (procedure "(value-at RES [COLUMN [ROW]] [raw: RAW])" (id value-at))) (p "Returns the value at the specified " (tt "COLUMN") " and " (tt "ROW") ".  It is parsed by an appropriate parser unless " (tt "RAW") " is specified and " (tt "#t") ".  If " (tt "RAW") " is true, the value is either a string, blob or an sql-null object.  Otherwise, it depends on the parsers.") (p "If " (tt "ROW") " or " (tt "COLUMN") " are not specified, they default to zero. This makes for more convenient syntax if you're just reading out a result of a query which always has one row or even one value.") (p "See " (int-link "#type-conversion" "type conversion") " for more info on parsers.")) (def (sig (procedure "(row-values RES [ROW] [raw: RAW])" (id row-values))) (p "Returns a list of all the columns' values at the given " (tt "ROW") " number. If " (tt "ROW") " is omitted, it defaults to zero.  If " (tt "RAW") " is true, the values are either strings, blobs or sql-null objects.  Otherwise, it depends on the parsers.")) (def (sig (procedure "(column-values RES [COLUMN] [raw: RAW])" (id column-values))) (p "Returns a list of all the rows' values at the given " (tt "COLUMN") " number. If " (tt "COLUMN") " is omitted, it defaults to zero.  If " (tt "RAW") " is true, the values are either strings, blobs or sql-null objects.  Otherwise, it depends on the parsers.")) (def (sig (procedure "(row-alist RES [ROW] [raw: RAW])" (id row-alist))) (p "Returns an alist of the values at the given " (tt "ROW") " number.  The keys of the alist are made up by the matching column names, as symbols.") (p "If " (tt "ROW") " is omitted, it defaults to zero.  If " (tt "RAW") " is true, the values are either strings, blobs or sql-null objects.  Otherwise, it depends on the parsers.")) (def (sig (procedure "(affected-rows RES)" (id affected-rows))) (p "For INSERT or UPDATE statements, this returns the number of rows affected by the statement that RES is a result for.  Otherwise it's zero.")) (def (sig (procedure "(inserted-oid RES)" (id inserted-oid))) (p "For INSERT statements resulting in a single record being inserted, this returns the OID (a number) assigned to the newly inserted row. Returns " (tt "#f") " for non-INSERT or multi-row INSERTs, or INSERTs into tables without OIDs.")) (def (sig (procedure "(row-count RES)" (id row-count))) (p "Returns the number of rows in the result set.")) (def (sig (procedure "(column-count RES)" (id column-count))) (p "Returns the number of columns in the result set.")) (def (sig (procedure "(column-index RES COLUMN)" (id column-index))) (p "Returns the index of " (tt "COLUMN") " in the result set. " (tt "COLUMN") " should be a symbol indicating the column name.")) (def (sig (procedure "(column-name RES INDEX)" (id column-name))) (p "Returns the name of the column (a symbol) at the position in the result set specified by " (tt "INDEX") ".  This is its aliased name in the result set.")) (def (sig (procedure "(column-names RES)" (id column-names))) (p "Returns a list of all the column names (symbols) in the result set. The position in the list reflects the position of the column in the result set.")) (def (sig (procedure "(column-format RES INDEX)" (id column-format))) (p "Returns the format of the column at " (tt "INDEX") ", which is a symbol; Either " (tt "text") " or " (tt "binary") ".  This determines whether the value returned by " (tt "value-at") " will be a string or a blob.")) (def (sig (procedure "(column-type RES INDEX)" (id column-type))) (p "Returns the OID (an integer) of the column at " (tt "INDEX") ".")) (def (sig (procedure "(column-type-modifier RES INDEX)" (id column-type-modifier))) (p "Returns an type-specific modifier (a number), or " (tt "#f") " if the type has no modifier.")) (def (sig (procedure "(table-oid RES INDEX)" (id table-oid))) (p "The OID (a number) of the table from whence the result column at " (tt "INDEX") " originated, or " (tt "#f") " if the column is not a simple reference to a table column.")) (def (sig (procedure "(table-column-index RES INDEX)" (id table-column-index))) (p "Returns the column number (within its table) of the column making up the query result column at the position specified by " (tt "INDEX") ".") (p (b "Note:") " This procedure returns indexes starting at zero, as one would expect.  However, the underlying C function " (tt "PQftablecol") " is one-based.  This might trip up experienced Postgres hackers."))) (section 4 "Value escaping" (p "To embed arbitrary values in query strings, you must escape them first, to protect yourself from SQL injection bugs.  This is not required if you use positional arguments (the " (tt "PARAMS") " arguments in the " (tt "query") " procedures).") (def (sig (procedure "(escape-string CONNECTION STRING)" (id escape-string))) (p "Quotes special characters in " (tt "STRING") " which are otherwise interpreted by the SQL parser, obeying the " (tt "CONNECTION") "'s encoding settings.")) (def (sig (procedure "(escape-bytea CONNECTION STRING)" (id escape-bytea))) (p "Quotes special characters in " (tt "STRING") " which are otherwise interpreted by the SQL parser.  This differs from " (tt "escape-string") " in that some bytes are doubly encoded so they can be used for bytea columns.") (p "This is required because of a technicality; PostgreSQL first parses the string value as a string, and then casts this string to bytea, interpreting another layer of escape codes.") (p "For example, " (tt "E'a\\\\000bcd'") " is first converted to " (tt "'a\\000bcd'") " by the text parser, and then interpreted by the bytea parser as an \"a\" followed by a NUL byte, followed by \"bcd\".  In Scheme, the value returned by " (tt "(escape-bytea conn \"a\\x00bcd\")") " is " (tt "\"a\\\\\\\\000bcd\"") ". Yes, that's a lot of backslashes :)")) (def (sig (procedure "(unescape-bytea STRING)" (id unescape-bytea))) (p "This unescapes a bytea " (b "result") " from the server.  It is " (b "not the inverse of " (tt "escape-bytea")) ", because string values returned by the server are not escaped for the text-parser. (ie, step one in the encoding process described under " (tt "escape-bytea") " is skipped)"))) (section 4 "COPY support" (section 5 "High-level COPY API" (p "This API is " (i "experimental") " and as such should be expected to change. If you have suggestions on how to improve the API, please let me know!") (def (sig (procedure "(copy-query-fold KONS KNIL CONNECTION QUERY . PARAMS)" (id copy-query-fold)) (procedure "(copy-query*-fold KONS KNIL CONNECTION QUERY [PARAMS] [format: FORMAT] [raw: RAW?])" (id copy-query*-fold))) (p "This is the fundamental " (tt "COPY TO STDOUT") " iterator. It calls " (tt "(kons data seed)") " for every row of COPY data returned by " (tt "QUERY") ", where " (tt "data") " is either a string or a blob depending on whether the " (tt "COPY") " query asked for binary or text data and " (tt "seed") " is the accumulated result from previous calls (initially " (tt "knil") "), ie its pattern looks like " (tt "(KONS DATAN ... (KONS DATA2 (KONS DATA1 KNIL)))") ". It returns the final accumulated result.") (p "The starred and nonstarred version are analogous to " (tt "query") " and " (tt "query*") ".") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n  (copy-query-fold\n    (lambda (data sum)\n      ;; Note the string-drop-right is necessary because the default\n      ;; COPY format uses newlines to indicate row endings\n      (+ (string->number (string-drop-right data 1)) sum))\n    0 conn \"COPY (SELECT 1 UNION SELECT 2) TO STDOUT\"))\n => 3")) (def (sig (procedure "(copy-query-fold-right KONS KNIL CONNECTION . PARAMS)" (id copy-query-fold-right)) (procedure "(copy-query*-fold-right KONS KNIL CONNECTION [PARAMS] [format: FORMAT] [raw: RAW?])" (id copy-query*-fold-right))) (p "The fundamental " (tt "COPY TO STDOUT") " recursion operator;  Calls " (tt "(KONS DATA1 (KONS DATA2 (KONS ... KNIL)))") " instead of " (tt "(KONS DATAN ... (KONS DATA2 (KONS DATA1 KNIL)))") ".") (p (b "Warning") ": It is not recommended to use this when the returned data is very big.  It is usually much cheaper (memory-wise) to use " (tt "copy-query-fold") " and reverse the result object, if the object's type supports that.") (p "The starred and nonstarred version are analogous to " (tt "query") " and " (tt "query*") ".")) (def (sig (procedure "(copy-query-map PROC CONNECTION . PARAMS)" (id copy-query-map)) (procedure "(copy-query*-map PROC CONNECTION [PARAMS] [format: FORMAT] [raw: RAW?])" (id copy-query*-map))) (p "Maps " (tt "COPY TO STDOUT") " output rows from " (tt "QUERY") " to lists by calling " (tt "PROC") " on each data row returned by the server.  If the " (tt "QUERY") " asked for binary data, the data supplied to " (tt "PROC") " will be in blob form.  Otherwise, the data will be provided as strings.") (p "The starred and nonstarred version are analogous to " (tt "query") " and " (tt "query*") ".") (highlight scheme "(use postgresql)\n\n(let ((conn (connect '((dbname . test)))))\n   (copy-map (lambda (x) (apply + (map string->number (string-split x))))\n             conn \"COPY (SELECT 1, 100 UNION SELECT 2, 200) TO STDOUT\"))\n => (101 202)")) (def (sig (procedure "(copy-query-for-each PROC CONNECTION . PARAMS)" (id copy-query-for-each)) (procedure "(copy-query*-for-each PROC CONNECTION [PARAMS] [format: FORMAT] [raw: RAW?])" (id copy-query*-for-each))) (p "Simple " (tt "for-each") ", calling the " (tt "(PROC data)") " on each row of " (tt "COPY TO STDOUT") " data returned by " (tt "QUERY") ", in turn, only for the purpose of its side-effects.") (p "The starred and nonstarred version are analogous to " (tt "query") " and " (tt "query*") ".")) (def (sig (procedure "(with-output-to-copy-query THUNK CONNECTION QUERY . PARAMS)" (id with-output-to-copy-query)) (procedure "(with-output-to-copy-query* THUNK CONNECTION QUERY [PARAMS] [format: FORMAT] [raw: RAW?])" (id with-output-to-copy-query*))) (p "Call " (tt "THUNK") " with " (tt "CURRENT-OUTPUT-PORT") " parameterized to a port that writes " (tt "COPY FROM STDIN") " data to the database connection " (tt "CONN") " for " (tt "QUERY") ".") (p "Returns the final result of " (tt "THUNK") ".") (p "The starred and nonstarred version are analogous to " (tt "query") " and " (tt "query*") ".") (highlight scheme "(use postgresql)\n\n(with-output-to-copy-query\n  (lambda () (print \"one\\t1\") (print \"two\\t2\") \"That's a wrap\")\n  conn \"COPY my_table (textcol, numbercol) FROM STDIN\")\n => \"That's a wrap\"")) (def (sig (procedure "(call-with-output-copy-query PROC CONNECTION QUERY . PARAMS)" (id call-with-output-copy-query)) (procedure "(call-with-output-copy-query* PROC CONNECTION QUERY [PARAMS] [format: FORMAT] [raw: RAW?])" (id call-with-output-copy-query*))) (p "Like " (tt "with-output-to-copy-query") ", except it calls " (tt "PROC") " with one argument (the copy port) instead of parameterizing " (tt "CURRENT-OUTPUT-PORT") "."))) (section 5 "Low-level COPY API" (p "This API is close to the C API.  It requires you to first execute a COPY query (using the " (tt "query") " procedure), and then you can put or get data from the connection.  You cannot run other queries while the connection is in COPY state.") (def (sig (procedure "(put-copy-data CONNECTION DATA)" (id put-copy-data))) (p "Put copy data on the " (tt "CONNECTION") ". " (tt "DATA") " is either a string, a blob or a u8vector and should be in the format expected by the server.")) (def (sig (procedure "(put-copy-end CONNECTION [ERROR-MESSAGE])" (id put-copy-end))) (p "This ends the COPY process.  If " (tt "ERROR-MESSAGE") " is supplied and not " (tt "#f") ", the data sent up till now is discarded by the server and an error message is triggered on the server.  If " (tt "ERROR-MESSAGE") " is not supplied or " (tt "#f") ", the server will commit the copied data to the target table and succeed.") (p "A result object is returned upon success.  This result object is currently not useful.")) (def (sig (procedure "(get-copy-data CONNECTION [format: FORMAT])" (id get-copy-data))) (p "Obtain one row of COPY data from the server.  The data's contents will be in the format indicated by the server.  If FORMAT is " (tt "'text") ", it the data will be returned as a string, if it is " (tt "'binary") ", it will be returned as a blob.  The user is responsible for providing the right format to match the output format of the query sent earlier.") (p "After the last row is received, this procedure returns a result object (which can be detected by calling " (tt "result?") " on it).")))) (section 4 "Constants" (def (sig (constant "invalid-oid" (id invalid-oid))) (p "Represents the numeric value of the invalid Oid.  Rarely useful, except perhaps when doing low-level operations in the system catalog."))) (section 4 "Error handling" (pre " condition: postgresql") (p "A condition of kind (exn postgresql) is signaled when an error occurs. The postgresql component of this condition contains several properties.  Unless otherwise noted, these properties may not be present, in which case they have the value " (tt "#f") ".") (dl (dt (tt "severity")) (dd "One of the symbols " (tt "error") ", " (tt "fatal") ", " (tt "panic") ", " (tt "warning") ",  " (tt "notice") ", " (tt "debug") ", " (tt "info") ", " (tt "log") ". Always present.") (dt (tt "error-class")) (dd "A string representing a Postgresql error class (the first two characters of " (tt "error-code") ").") (dt (tt "error-code")) (dd "A string representing a Postgresql error code.  See the " (link "http://www.postgresql.org/docs/8.3/static/errcodes-appendix.html" "Postgresql documentation") " for a description of error codes and error classes.") (dt (tt "message-detail")) (dd "A secondary (to the usual " (tt "exn message") " property) message with extra detail about the problem.") (dt (tt "message-hint")) (dd "A string with a suggestion about what to do about the problem.") (dt (tt "statement-position")) (dd "An integer indicating an error cursor position as an index into the original statement string. The first character has index 1, and positions are measured  in characters, not bytes.") (dt (tt "context")) (dd "An indication of the context in which the error occurred. Presently this includes a call stack traceback of active PL functions. The trace is one entry per line, most recent first.") (dt (tt "source-file")) (dd "The file name of the Postgresql source-code location where the error was reported.") (dt (tt "source-line")) (dd "A string containing the line number of the Postgresql source-code location where the error was reported.") (dt (tt "source-function")) (dd "The name of the source-code function reporting the error."))) (section 4 "Type conversion" (p "Type information is read from the database the first time you connect to it.  Result set values are either text or binary (or sql null).  If they are text, they are converted to Scheme objects by type parsers, as described below.  If they are binary, they will be returned as unprocessed blobs (which you can then convert to u8vectors or strings).") (section 5 "Parsers" (def (sig (parameter "(default-type-parsers [ALIST])" (id default-type-parsers))) (p "Postgres result values are always just strings, but it is possible to map these to real Scheme objects.  With this parameter, you can map your own custom postgresql datatype to Scheme datatypes.") (p "The alist is a mapping of Postgres type names (strings) to procedures accepting a string and returning a Scheme object of the desired type.") (p "The parsers can also be set per connection with the " (tt "TYPE-PARSERS") " argument of the " (tt "connect") " procedure.") (highlight scheme "(use postgresql)\n\n(parameterize ((default-type-parsers `((\"text\" . ,string->symbol))))\n  (let ((conn (connect '((dbname . test)))))\n    (symbol? (value-at (query conn \"SELECT 'hello'::text\")))))\n => #t") (p "The default parsers look like this:") (highlight scheme "`((\"text\" . ,identity)\n  (\"bytea\" . ,bytea-parser)\n  (\"char\" . ,char-parser)\n  (\"bpchar\" . ,identity)\n  (\"bool\" . ,bool-parser)\n  (\"int8\" . ,numeric-parser)\n  (\"int4\" . ,numeric-parser)\n  (\"int2\" . ,numeric-parser)\n  (\"float4\" . ,numeric-parser)\n  (\"float8\" . ,numeric-parser)\n  (\"numeric\" . ,numeric-parser)\n  (\"oid\" . ,numeric-parser)\n  (\"record\" . ,(make-composite-parser (circular-list identity))))") (p "These parsers are described below.  For anything where no parser is found, the value is returned verbatim (which is always a string, or a blob in case of binary data).") (p "Array and composite (row) types are automatically handled; unless a type-specific parser is defined, a parser is automatically created by combining the parsers for their constituent elements.")) (def (sig (procedure "(update-type-parsers! CONN [TYPE-PARSERS])" (id update-type-parsers!))) (p "As described above, type information is extracted from the system catalog whenever you initiate a new connection.  However, there is a bootstrapping problem when you are defining custom data types.  You must first connect before you can define your custom data types.  But the type parsers do not have the information for this new type yet, so you must update them.") (p "To do this, you can call " (tt "update-type-parsers!") ".  This procedure updates all the type parsers originally associated with connection " (tt "CONN") ".  By providing the optional " (tt "TYPE-PARSERS") ", you can override the existing type parsers for this connection with new ones, otherwise the old ones are just refreshed.")) (def (sig (procedure "(bool-parser STR)" (id bool-parser))) (p "Returns " (tt "#t") " if the string equals " (tt "\"t\"") ", " (tt "#f") " otherwise.")) (def (sig (procedure "(bytea-parser STR)" (id bytea-parser))) (p "Returns a u8vector containing the bytes in STR, after unescaping it using " (tt "unescape-bytea") ".")) (def (sig (procedure "(char-parser STR)" (id char-parser))) (p "Returns the first character in STR.")) (def (sig (procedure "(numeric-parser STR)" (id numeric-parser))) (p "Returns " (tt "STR") " converted to a number using decimal representation. If " (tt "STR") " could not be converted to a number, raises an error.")) (def (sig (procedure "(make-array-parser SUBPARSER [DELIMITER])" (id make-array-parser))) (p "Returns a procedure that can be used to parse arrays containing elements that " (tt "SUBPARSER") " parses.  It will split the elements using the " (tt "DELIMITER") " character, which defaults to " (tt "#\\,") ".") (p "For example, to create a parser for arrays of integers, use " (tt "(make-array-parser numeric-parser)") ".")) (def (sig (procedure "(make-composite-parser SUBPARSERS)" (id make-composite-parser))) (p "Returns a procedure that can be used to parse composite values (aka \"row values\").  It will use the list of " (tt "SUBPARSERS") " to parse each element in the row by looking up the parser at the matching position in the list.  For example, to create a parser for rows containing an integer and a boolean, use " (tt "(make-composite-parser (list numeric-parser bool-parser))") "."))) (section 5 "Unparsers" (def (sig (parameter "(default-type-unparsers [ALIST])" (id default-type-unparsers))) (p "Just as PostgreSQL types are converted to Scheme types in result sets, Scheme types need to be converted to PostgreSQL types when providing positional parameters to queries.  For this, the library uses type unparsers.  Just like type parsers, you can override them either per-connection using the " (tt "TYPE-UNPARSERS") " parameter to the " (tt "connect") " procedure, or globally by changing a parameter.") (p "This alist is a mapping of predicates to unparsers.  Predicates are procedures which accept a scheme object and return a true value if the object is of the type for which the unparser is intended.  Unparsers are procedures which accept two arguments; the connection object and the scheme object to unparse.  Unparsers return either a string, a blob or an sql-null object to be used in the query.") (p "It is not necessary to reload type unparsers after defining a new data type in the database.") (p "Order matters; the type unparser alist is traversed from left to right, trying predicates in order and invoking the unparser linked to the first predicate that does not return " (tt "#f") ".  If none of the predicates match, the type must be of string, blob or sql-null type. If not, the query procedure will raise an error.") (p "The default unparsers look like this:") (highlight scheme "`((,string? . ,(lambda (conn s) s))\n  (,u8vector? . ,(lambda (conn v) (u8vector->blob/shared v)))\n  (,char? . ,(lambda (conn c) (string c)))\n  (,boolean? . ,bool-unparser)\n  (,number? . ,(lambda (conn n) (number->string n)))\n  (,vector? . ,vector-unparser)\n  (,pair? . ,list-unparser))")) (def (sig (procedure "(update-type-unparsers! CONN TYPE-UNPARSERS)" (id update-type-unparsers!))) (p "Similar to " (tt "update-type-parsers!") ", this procedure allows you to update all the type unparsers originally associated with connection " (tt "CONN") ".")) (def (sig (procedure "(bool-unparser CONN B)" (id bool-unparser))) (p "Returns " (tt "\"TRUE\"") " for true values and " (tt "\"FALSE\"") " for " (tt "#f") ".")) (def (sig (procedure "(vector-unparser CONN V)" (id vector-unparser))) (p "Returns a string representing an array containing the objects in the vector " (tt "V") ".  The elements of " (tt "V") " are unparsed recursively by their respective subparsers.  It is the responsibility of the program to use correct values for an array; the elements should all be of the same type and, if they are vectors themselves, all vectors should have the same length and recursive vector depth.  Otherwise, you will get an error from postgresql.")) (def (sig (procedure "(list-unparser CONN L)" (id list-unparser))) (p "Returns a string representing a composite object (aka row value) containing the objects in the list " (tt "L") ".  The elements of " (tt "L") " are unparsed recursively by their respective subparsers."))))) (section 3 "Changelog" (ul (li "3.6.2 Fix tests for postgresql 9.0, prefer one null column over zero columns when faced with ambiguous composite value output syntax \"" (tt "()") "\".") (li "3.6.1 Fix a small problem in the way composite values are parsed so that trailing NULL values are properly deserialized.") (li "3.6 Fix problem with built-in \"name\" type which got falsely interpreted as an array (and possibly others as well) [Reported by David Krentzlin]. Fix foreign type signature for " (tt "escape-bytea") " internal function so it correctly accepts bytea values containing NUL bytes (Chicken 4.6.0 and later).") (li "3.5.1 Small change in type information query so it works in Postgres 8.2 (and possibly older versions). [Thanks to Alaric Snell-Pym and Florian Zumbiehl]") (li "3.5 Add support for composite and array types.  Change semantics of 'raw' option to " (tt "query*") " procedure. Backwards incompatible change; pass connection to all type unparsers.") (li "3.4.1 Improve COPY interface") (li "3.4 Add \"raw\" option to row-alist for consistency. Fix library flags in setup script [Thanks to Felix]. Add " (tt "COPY") " support. Remove " (tt "multi-query") ".") (li "3.3 - Fix connection over TCP/IP problem") (li "3.2 - Add transaction support.") (li "3.1 - Small (but backwards incompatible) interface improvement: make row and column arguments optional.") (li "3.0 - Port to Chicken 4.  Major code overhaul, backwards incompatible.") (li "2.0.14 - Add PQescapeStringConn functionality to pg:escape-string. Fixed weird compilation issue with SRFI-69 by removing it from USES list.") (li "2.0.12 - added " (tt "pg:named-tuples") " parameter [Contributed by Graham Fawcett]") (li "2.0.11 - added syntax-case requirements to .meta file [Thanks to Michele Simionato]") (li "2.0.10 - adapted to new easyffi usage [Thanks to rreal]") (li "2.0.9 - Yet more improvements to error reporting") (li "2.0.8 - More detailed error information, export " (tt "pg:sql-null-object")) (li "2.0.7 - Added missing error-function [Thanks to Reed Sheridan]") (li "2.0.6 - Removed dependency on format [Thanks to Reed Sheridan]") (li "2.0.5 - Some bugfixes and " (tt "pq:escape-string") " by Reed Sheridan; adapted to SRFI-69 hash-tables") (li "2.0.4 - Changed usage of hygienic macros in setup script") (li "2.0.3 - Bugfixes.") (li "2.0.0 - Interface improvements.  (Backward-incompatible.)") (li "1.2.1 - Non-blocking queries.") (li "1.2.0 - Optimizations, minor fixes and cleanups."))) (section 3 "License" (pre " Copyright (C) 2008-2009 Peter Bex\n Copyright (C) 2004 Johannes Grødem <johs@copyleft.no>\n Redistribution and use in source and binary forms, with or without\n modification, is permitted.\n \n THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE\n LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n DAMAGE."))))